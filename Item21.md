# Item21. 인터페이스는 구현하는 쪽을 생각해 설계하라

<br>

## 불변식을 해치지 않는 `default` 메서드를 작성하기 어렵다. 
자바 8 이전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다. 

자바 8에서 와서 인터페이스에 `default` 메서드를 추가할 수 있게 되어 구현체를 깨뜨리지 않고 메서드를 추가할 수 있게 되었다.

하지만 구현체를 깨뜨리지 않는 위험이 아예 사라진 것은 아니다. 

`default` 메서드를 구현하게 되면 해당 메서드를 재정의하지 않은 모든 클래스에서 `default` 구현이 쓰이게 되는데, 이는 모든 구현체들과 매끄럽게 동작하리라는 보장은 없다.

**다시 말하면, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 `default` 메서드를 작성하기는 어렵다.**

다음 예시를 보도록 하자.

자바 8의 `Collection` 인터페이스에 추가된 `removeIf` 메서드는 주어진 `boolean` 함수인 `predicate`가 `true`를 반환하는 모든 원소를 제거한다.

하지만 이 메서드가 모든 구현체와 잘 어우러지는 것은 아니다.

`apache.commons`의 `SynchronizedCollection`만 보더라도 4.4 이전 버전까지 아래와 같이 `removeIf` 메서드가 재정의되지 않았다.
> `SynchronizedCollection` 클래스는 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스이다.

**버전 3.3**

![image](https://user-images.githubusercontent.com/76088639/161576136-8406bd72-e8e4-4932-880d-7c2f1f85d37c.png)

**버전 4.4**

![image](https://user-images.githubusercontent.com/76088639/161577215-bdb08433-0bf1-4b2a-bbeb-bf10d4c68dd8.png)


이 클래스를 자바 8과 함께 사용한다면 `removeIf` 메서드의 `default` 구현을 물려받게 되고, 이는 동기화를 지원하지 않기 때문에 결국 `SynchronizedCollection` 클래스는 기능을 잃게 된다.

따라서 멀티 스레드 환경에서 `removeIf` 메서드를 호출하면 `ConcurrentModificationException`이 발생하거나 다른 예기치 못한 결과로 이어질 수 있다.

**`default` 메서드는 이처럼 기존 구현체에 런타임 오류를 일으킬 수 있다.**

<br>

## 기존 인터페이스에 `default` 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피하라
추가하려는 `default` 메서드가 기존 구현체들과 충돌하지는 않을지 심사숙고해야 한다.

`default` 메서드가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.

그렇지 않으면 기존 클라이언트를 망가뜨리게 된다.

새로운 인터페이스를 릴리즈 하기 전에 반드시 테스트를 거쳐야 한다. 서로 다른 방식으로 최소 3가지는 구현해봐야 한다. 

인터페이스를 릴리즈한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안 된다.
