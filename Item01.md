# Item01. 생성자 대신 정적 팩터리 메서드를 고려하라
- 클래스는 클라이언트에 public 생성자 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다.
- 이러한 정적 팩터리 메서드의 장단점은 아래와 같다.

<br>

### 장점1: 이름을 가질 수 있다.
- 한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주는 것이 좋다.
- 하나의 시그니처로는 생성자를 하나만 만들 수 있는데, 정적 팩터리 메서드를 사용하면 이를 가능하게 할 수 있고, **클라이언트 코드의 가독성 또한 좋아진다**.
- 예를 들어 다음과 같은 `Person` 클래스가 있다고 가정해보도록 하자.
```java
public class Person {
  String name;
  String address;

  public Person(String name) {
      this.name = name;
  }

  // 동일한 시그니처 생성자는 만들 수 없다. -> 컴파일 에러
  public Person(String address) {
      this.address = address;
  }
}
```
- 이때 하나의 시그니처로는 하나의 생성자만 만들 수 있기 때문에 위 코드는 컴파일 에러가 발생한다.
- 반면 정적 팩터리 메서드를 사용하면 이를 극복할 수 있고, 가독성 또한 좋아진다. 코드는 아래와 같다.
```java
public class Person {
  String name;
  String address;

  public Person() {
  }

  public Person(String name) {
      this.name = name;
  }

  public static Person createWithName(String name) {
      return new Person(name);
  }

  public static Person createWitAddress(String address) {
      Person person = new Person();
      person.address = address;
      return person;
  }

  public static void main(String[] args) {
      Person person = new Person("name");
      Person person = Person.createWithName("name"); // 가독성 더 좋다.
  }

}
```
<br>

### 장점2: 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
- 덕분에 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.
- `Boolean.valueOf(boolean)` 메소드가 그 예이다.
<br>

### 장점3: 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
- 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 엄청난 유연성을 선물한다.
- 이는 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이기도 하다.
- 리턴 타입을 인터페이스로 두고, 실제 리턴하는 객체를 인터페이스의 구현체를 리턴하는 것이다.
  - 그렇게 되면 **클라이언트는 인터페이스만 바라볼 수 있기 때문에 유연한 설계를 가져다준다.**
  - `java.util.Collections` 가 그 예이다.
<br>

### 장점4: 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 반환 타입이 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
- 예를 들어 `EnumSet` 클래스는 public 생성자 없이 정적 팩터리만 제공하는데, 원소의 수에 따라 `RegularEnumSet`혹은 `JumboEnumSet`의 인스턴스를 반환한다.
- **클라이언트는 위 두 클래스의 존재를 몰라도 되며, 알 필요도 없고 `EnumSet`의 하위 클래스이기만 하면 된다.**
- 이 장점 또한 정적 팩터리 메서드가 가진 유연성에 대해 말하고 있는 것이다.
<br>

### 장점5: 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 마찬가지로 유연함에 대한 이야기이다.
- 인터페이스를 반환 타입으로 두면, 정적 팩터리 메서드를 만든 이후에 인터페이스를 상속 받은 반환할 객체의 클래스를 만들어도 된다는 것이다.
- 또한 이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이 된다.
  - 서비스 제공자 프레임워크의 대표적인 예시로는 JDBC가 있다.
  - JDBC의 경우, 아래 3가지 핵심 컴포넌트로 구성되어 있다.
    1. 구현체의 동작을 정의하는 서비스 인터페이스
        - `Connection`인터페이스
    2. 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API
        - `DriverManager.registerDriver();`
    3. 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API로 이뤄진다.
        - `DriverManager.getConnection("jdbc:h2:tcp://localhost/~/test", "sa", "");`
        - 이 서비스 접근 API가 서비스 제공자 프레임워크의 근간이라고 한 유연한 정적 팩터리의 실체이다.
<br>

### 단점1: 상속을 하려면 `public`이나 `protected` 생성자가 필요하니 정적 패터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
- `Collections` 클래스는 상속할 수 없다.
- 이 제약은 상속보다 컴포지션을 사용하도록 유도하고, 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점이 될 수 있다.
<br>

### 단점2: 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다.
<br>

## 정리
- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다.
- 그렇다고 하더라도 정적 팩터리 메서드를 사용하게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.
- 정적 팩터리 메서드는 public 생성자 방식보다 더 유연한 설계를 가져갈 수 있다는 것이 장점인 것 같다.
- 반환 타입의 하위 타입 인스턴스를 반환할 수 있기 때문에 인터페이스를 두고, 클라이언트가 유연하게 사용할 인스턴스를 선택할 수 있다는 점이 좋은 것 같다.
- 또한 가독성 좋은 클라이언트 코드를 작성할 수 있다는 점도 매력적으로 다가온다.
